# ТЗ для Anthropic AI: Реализация модуля SmartSeparation (UltimateRecovery v11.5)

## 1. Проблема: "Склейка Франкенштейна"
Текущий алгоритм `Super Grouping` в Python и `RustFragmentLinker` в Rust используют упрощенный анализ сходства (Jaccard). Если на диске перемешаны фрагменты двух разных файлов со схожим типом контента (например, список YouTube-ссылок и список TikTok-ссылок), они ошибочно объединяются в один файл.

**Пример перемешивания:**
- Фрагмент A1 (YouTube ссылки)
- Фрагмент B1 (TikTok ссылки)
- Фрагмент A2 (YouTube ссылки)
- Результат сейчас: [A1, B1, A2] -> Один файл.
- Ожидаемый результат: [A1, A2] -> Файл А, [B1] -> Файл B.

## 2. Задача
Реализовать модуль `accelerator/src/clusterer.rs` на Rust, который обеспечит "умное" разделение потоков.

### Ключевые требования:
1.  **N-gram Content Profiling:** Вместо сравнения только ссылок, нужно анализировать частоту байтовых последовательностей (N-граммы) и "ключевых якорей" (например, `youtube.com` vs `tiktok.com`, или специфические JSON-ключи).
2.  **Weighted Cosine Similarity:** Использовать косинусное сходство векторов признаков. Это позволит отличить файлы с разным семантическим уклоном.
3.  **Physical Distance Decay:** Внедрить коэффициент затухания. Если фрагменты семантически близки, но находятся на расстоянии 1 ГБ друг от друга, вероятность их связи стремится к нулю. `FinalScore = Similarity * exp(-k * ΔOffset)`.
4.  **SIMD Acceleration (AVX2):** Расчет скалярного произведения векторов для косинусного сходства должен быть оптимизирован через AVX2 (`_mm256_mul_ps`, `_mm256_add_ps`).
5.  **O(N log N) Complexity:** Использовать пространственное индексирование или ограничение окна поиска по офсету, чтобы не сравнивать каждый фрагмент с каждым на терабайтных образах.

## 3. Ожидаемая архитектура (Rust)
```rust
pub struct FragmentClusterer {
    config: ClusterConfig,
}

impl FragmentClusterer {
    pub fn cluster_fragments(&self, fragments: Vec<RawFragment>) -> Vec<Cluster> {
        // 1. Построение векторов признаков (SIMD)
        // 2. Расчет матрицы сходства с учетом физического расстояния
        // 3. Кластеризация (например, Single-Linkage с порогом)
    }
}
```

## 4. Контекст из кода
- См. `fragment_linker.rs` — там текущая (плохая) реализация.
- См. `simd_search.rs` — там примеры использования AVX2 в проекте.
- См. `types.rs` — там структура `HotFragment`, которую нужно расширить вектором признаков.

## 5. Инструкция для исполнения
Напиши полный код `clusterer.rs` и предложи изменения в `lib.rs` для интеграции нового функционала. Код должен быть "военного уровня": максимально быстрым, безопасным и устойчивым к мусору в данных.
